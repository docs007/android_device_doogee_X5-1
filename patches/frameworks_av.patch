From f36bdecb780a2dec5f7e07fe76de4c09e58b980f Mon Sep 17 00:00:00 2001
From: DeckerSU <support@decker.su>
Date: Mon, 12 Dec 2016 05:36:02 +0200
Subject: [PATCH] mtk audio fix

Change-Id: I9b5753457cb26d8ac47052674ebe6c7c18666a92
---
 media/libmedia/Android.mk         |  11 +-
 media/libmedia/mtkaudio_stubs.cpp | 215 ++++++++++++++++++++++++++++++++++++++
 2 files changed, 224 insertions(+), 2 deletions(-)
 create mode 100644 media/libmedia/mtkaudio_stubs.cpp

diff --git a/media/libmedia/Android.mk b/media/libmedia/Android.mk
index df4e4b6..34f6128 100644
--- a/media/libmedia/Android.mk
+++ b/media/libmedia/Android.mk
@@ -7,7 +7,7 @@ LOCAL_SRC_FILES:= \
 LOCAL_MODULE:= libmedia_helper
 LOCAL_MODULE_TAGS := optional
 
-LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
+LOCAL_CFLAGS += -Wno-error=deprecated-declarations -Wall
 LOCAL_CLANG := true
 
 include $(BUILD_STATIC_LIBRARY)
@@ -97,7 +97,14 @@ LOCAL_C_INCLUDES := \
     $(call include-path-for, audio-effects) \
     $(call include-path-for, audio-utils)
 
-LOCAL_CFLAGS += -Werror -Wno-error=deprecated-declarations -Wall
+### audio.primary.mt6580.so ->_ZN7android11AudioSystem24getVoiceUnlockDLInstanceEv ###
+LOCAL_SRC_FILES += \
+    mtkaudio_stubs.cpp
+
+# StrongPointer.h
+LOCAL_C_INCLUDES += $(TOP)/frameworks/rs/server
+
+LOCAL_CFLAGS += -Wno-error=deprecated-declarations -Wall
 LOCAL_CLANG := true
 LOCAL_SANITIZE := unsigned-integer-overflow signed-integer-overflow
 
diff --git a/media/libmedia/mtkaudio_stubs.cpp b/media/libmedia/mtkaudio_stubs.cpp
new file mode 100644
index 0000000..26802ef
--- /dev/null
+++ b/media/libmedia/mtkaudio_stubs.cpp
@@ -0,0 +1,215 @@
+// #include <MtpTypes.h>
+#include <system/audio.h>
+#include <StrongPointer.h>
+#include <media/IAudioFlinger.h>
+#include <hardware/audio.h>
+#include <stdlib.h>
+#include <dlfcn.h>
+
+namespace android {
+
+typedef void (*audio_error_callback)(status_t err);
+
+class AudioSystem
+{
+public:
+    static bool getVoiceUnlockDLInstance();
+    static int GetVoiceUnlockDLLatency();
+    static int SetVoiceUnlockSRC(uint outSR, uint outChannel);
+    static bool stopVoiceUnlockDL();
+    static bool startVoiceUnlockDL();
+    static int ReadRefFromRing(void*buf, uint32_t datasz,void* DLtime);
+    static int GetVoiceUnlockULTime(void* DLtime);
+    static void freeVoiceUnlockDLInstance();
+
+}; // class
+
+bool AudioSystem::getVoiceUnlockDLInstance()
+{
+  return 0;
+}
+
+int AudioSystem::GetVoiceUnlockDLLatency()
+{
+  return 0;
+}
+
+int AudioSystem::SetVoiceUnlockSRC(uint outSR, uint outChannel)
+{
+  return 0;
+}
+
+bool AudioSystem::stopVoiceUnlockDL()
+{
+  return 0;
+}
+
+bool AudioSystem::startVoiceUnlockDL()
+{
+  return 0;
+}
+
+int AudioSystem::ReadRefFromRing(void*buf, uint32_t datasz,void* DLtime)
+{
+  return 0;
+}
+
+int AudioSystem::GetVoiceUnlockULTime(void* DLtime)
+{
+  return 0;
+}
+
+void AudioSystem::freeVoiceUnlockDLInstance()
+{
+  return;
+}
+
+class IATVCtrlClient
+{
+};
+
+class IATVCtrlService: public IInterface
+{
+public:
+  DECLARE_META_INTERFACE(ATVCtrlService);
+};
+
+class BpATVCtrlService : public BpInterface<IATVCtrlService>
+{
+public:
+    BpATVCtrlService(const sp<IBinder>& impl)
+        : BpInterface<IATVCtrlService>(impl)
+    {
+    }
+    virtual ~BpATVCtrlService()
+    {
+    }
+    virtual int ATVCS_matv_init()
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_ps_init(int on)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_set_parameterb(int in)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_suspend(int on)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_shutdown()
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_chscan(int mode)
+    {
+    }
+    virtual void ATVCS_matv_chscan_stop()
+    {
+    }
+    virtual int ATVCS_matv_get_chtable(int ch, void *entry, int len)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_set_chtable(int ch, void *entry, int len)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_clear_chtable()
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_change_channel(int ch)
+    {
+    }
+    virtual void ATVCS_matv_set_country(int country)
+    {
+    }
+    virtual void ATVCS_matv_set_tparam(int mode)
+    {
+    }
+    virtual void ATVCS_matv_audio_play()
+    {
+    }
+    virtual void ATVCS_matv_audio_stop()
+    {
+    }
+    virtual int ATVCS_matv_audio_get_format()
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_audio_set_format(int val)
+    {
+    }
+    virtual int ATVCS_matv_audio_get_sound_system()
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_adjust(int item, int val)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_get_chipdep(int item)
+    {
+        return 0;
+    }
+    virtual int ATVCS_matv_set_chipdep(int item, int val)
+    {
+        return 0;
+    }
+    virtual void ATVCS_matv_register_callback()
+    {
+    }
+    virtual void registerClient(const sp<IATVCtrlClient>& client)
+    {
+    }
+    virtual void registerClient_FM(const sp<IATVCtrlClient>& client)
+    {
+    }
+    virtual void CLI(char input)
+    {
+    }
+    virtual int ATVCS_fm_powerup(void *parm, int len)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_powerdown()
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_getrssi()
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_tune(void *parm, int len)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_seek(void *parm, int len)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_scan(void *parm, int len)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_mute(int val)
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_getchipid()
+    {
+        return 0;
+    }
+    virtual int ATVCS_fm_isFMPowerUp()
+    {
+        return 0;
+    }
+};
+
+IMPLEMENT_META_INTERFACE(ATVCtrlService, "android.media.IATVCtrlService");
+
+} // namespace
\ No newline at end of file
-- 
2.7.4



From 1e11edfe6fb5335665f46d1def292b9ca977bc52 Mon Sep 17 00:00:00 2001
From: DeckerSU <support@decker.su>
Date: Sat, 18 Feb 2017 23:46:58 +0300
Subject: [PATCH 4/6] Disable usage of get_capture_position

'get_capture_position' is a newly introduced API that is not yet
supported by Meizu audio HAL (as of 4.5.4I stock image), so
we disable its usage to avoid crash

Thx to: Dmitry Smirnov <divis1969@gmail.com>

Change-Id: I2d5dc09558034f5253e8c9330e9980225a21201c
---
 services/audioflinger/Threads.cpp | 29 +++++++++++++++--------------
 1 file changed, 15 insertions(+), 14 deletions(-)

diff --git a/services/audioflinger/Threads.cpp b/services/audioflinger/Threads.cpp
index 08ccc8e..e3599a3 100644
--- a/services/audioflinger/Threads.cpp
+++ b/services/audioflinger/Threads.cpp
@@ -6448,20 +6448,21 @@ reacquire_wakelock:
         mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_SERVER] = systemTime();
 
         // Update server timestamp with kernel stats
-        if (mInput->stream->get_capture_position != nullptr
-                && mPipeSource.get() == nullptr /* don't obtain for FastCapture, could block */) {
-            int64_t position, time;
-            int ret = mInput->stream->get_capture_position(mInput->stream, &position, &time);
-            if (ret == NO_ERROR) {
-                mTimestamp.mPosition[ExtendedTimestamp::LOCATION_KERNEL] = position;
-                mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_KERNEL] = time;
-                // Note: In general record buffers should tend to be empty in
-                // a properly running pipeline.
-                //
-                // Also, it is not advantageous to call get_presentation_position during the read
-                // as the read obtains a lock, preventing the timestamp call from executing.
-            }
-        }
+
+        // if (mInput->stream->get_capture_position != nullptr
+        //         && mPipeSource.get() == nullptr /* don't obtain for FastCapture, could block */) {
+        //     int64_t position, time;
+        //     int ret = mInput->stream->get_capture_position(mInput->stream, &position, &time);
+        //     if (ret == NO_ERROR) {
+        //         mTimestamp.mPosition[ExtendedTimestamp::LOCATION_KERNEL] = position;
+        //         mTimestamp.mTimeNs[ExtendedTimestamp::LOCATION_KERNEL] = time;
+        //         // Note: In general record buffers should tend to be empty in
+        //         // a properly running pipeline.
+        //         //
+        //         // Also, it is not advantageous to call get_presentation_position during the read
+        //         // as the read obtains a lock, preventing the timestamp call from executing.
+        //     }
+        // }
         // Use this to track timestamp information
         // ALOGD("%s", mTimestamp.toString().c_str());
 
-- 
2.7.4



From 0f5acb0a5ee4663072e1d3302fbbe0d719c96b68 Mon Sep 17 00:00:00 2001
From: DeckerSU <support@decker.su>
Date: Sun, 19 Feb 2017 02:21:55 +0300
Subject: [PATCH 1/2] Partial Revert "Camera1 API: Support SW encoders for new
 camera HALs"

Read this:

- https://github.com/xen0n/android_frameworks_av_mtk/commit/0e8649c
- https://github.com/LineageOS/android_frameworks_av/commit/6b0795009b8f53ab771e0074b76381977d016f4b
- https://github.com/ResurrectionRemix-mtk/android_frameworks_av-rr/commit/f4f0f3d4201f573f8a522e50e4a00c1ac1c6a29d

This patch is a dirty compilation of these fixes. Main idea is to set storeMetaDataInVideoBuffers
to false everythere. But this may affect other codecs :(

Change-Id: Id7570b388a21e332eaca843a3e7d432db2453f7c
---
 include/media/stagefright/CameraSource.h            |  2 +-
 media/libmediaplayerservice/StagefrightRecorder.cpp |  2 +-
 media/libstagefright/CameraSource.cpp               | 10 ----------
 3 files changed, 2 insertions(+), 12 deletions(-)

diff --git a/include/media/stagefright/CameraSource.h b/include/media/stagefright/CameraSource.h
index c2e75a6..f39688f 100644
--- a/include/media/stagefright/CameraSource.h
+++ b/include/media/stagefright/CameraSource.h
@@ -89,7 +89,7 @@ public:
                                           Size videoSize,
                                           int32_t frameRate,
                                           const sp<IGraphicBufferProducer>& surface,
-                                          bool storeMetaDataInVideoBuffers = true);
+                                          bool storeMetaDataInVideoBuffers = false);
 
     virtual ~CameraSource();
 
diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index a6558ab..353bc02 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1499,7 +1499,7 @@ status_t StagefrightRecorder::setupCameraSource(
         *cameraSource = AVFactory::get()->CreateCameraSourceFromCamera(
                 mCamera, mCameraProxy, mCameraId, mClientName, mClientUid, mClientPid,
                 videoSize, mFrameRate,
-                mPreviewSurface);
+                mPreviewSurface, false); // [*] Decker
     }
     AVUtils::get()->cacheCaptureBuffers(mCamera, mVideoEncoder);
     mCamera.clear();
diff --git a/media/libstagefright/CameraSource.cpp b/media/libstagefright/CameraSource.cpp
index fc45e38..b51a7b8 100644
--- a/media/libstagefright/CameraSource.cpp
+++ b/media/libstagefright/CameraSource.cpp
@@ -759,16 +759,6 @@ status_t CameraSource::startCameraRecording() {
             }
         }
 
-        err = mCamera->sendCommand(
-            CAMERA_CMD_SET_VIDEO_FORMAT, mEncoderFormat, mEncoderDataSpace);
-
-        // This could happen for CameraHAL1 clients; thus the failure is
-        // not a fatal error
-        if (err != OK) {
-            ALOGW("Failed to set video encoder format/dataspace to %d, %d due to %d",
-                    mEncoderFormat, mEncoderDataSpace, err);
-        }
-
         // Create memory heap to store buffers as VideoNativeMetadata.
         createVideoBufferMemoryHeap(sizeof(VideoNativeHandleMetadata), kDefaultVideoBufferCount);
     }
-- 
2.7.4



From 979f7fd62ff43c1e3f74629344b67fd8fc37379c Mon Sep 17 00:00:00 2001
From: DeckerSU <support@decker.su>
Date: Tue, 20 Dec 2016 05:38:32 +0200
Subject: [PATCH] Use hw encoder only for camera [fire855]

Change-Id: I5ec242db9dca36bd530a771321a991dbc5fb5e5b
---
 media/libmediaplayerservice/StagefrightRecorder.cpp |  8 ++++++++
 media/libstagefright/MediaCodecList.cpp             | 11 +++++++++++
 media/libstagefright/MediaCodecSource.cpp           |  6 ++++++
 3 files changed, 25 insertions(+)

diff --git a/media/libmediaplayerservice/StagefrightRecorder.cpp b/media/libmediaplayerservice/StagefrightRecorder.cpp
index d7bb876..d0fb562 100644
--- a/media/libmediaplayerservice/StagefrightRecorder.cpp
+++ b/media/libmediaplayerservice/StagefrightRecorder.cpp
@@ -1562,6 +1562,14 @@ status_t StagefrightRecorder::setupVideoEncoder(
             break;
     }
 
+    // force hw video encoder for camera
+    if (mVideoSource == VIDEO_SOURCE_CAMERA) {
+        AString mime;
+        CHECK(format->findString("mime", &mime));
+        mime.append("_cam");
+        format->setString("mime", mime);
+    }
+
     if (cameraSource != NULL) {
         sp<MetaData> meta = cameraSource->getFormat();
 
diff --git a/media/libstagefright/MediaCodecList.cpp b/media/libstagefright/MediaCodecList.cpp
index 64c6253..4764810 100644
--- a/media/libstagefright/MediaCodecList.cpp
+++ b/media/libstagefright/MediaCodecList.cpp
@@ -1158,6 +1158,17 @@ void MediaCodecList::findMatchingCodecs(
         return;
     }
 
+    AString *tempMime = new AString(mime);
+    if (tempMime->endsWith("_cam")) {
+        // remove camera tag from mime
+        tempMime->erase(tempMime->size() - 4, 4);
+        mime = tempMime->c_str();
+    }
+    else {
+        // no camera recording, prefer software codecs
+        flags |= kPreferSoftwareCodecs;
+    }
+
     size_t index = 0;
     for (;;) {
         ssize_t matchIndex =
diff --git a/media/libstagefright/MediaCodecSource.cpp b/media/libstagefright/MediaCodecSource.cpp
index f66215f..9f2ade6 100755
--- a/media/libstagefright/MediaCodecSource.cpp
+++ b/media/libstagefright/MediaCodecSource.cpp
@@ -483,6 +483,12 @@ status_t MediaCodecSource::initEncoder() {
                 &matchingCodecs);
     }
 
+    // remove camera tag from mime
+    if (outputMIME.endsWith("_cam")) {
+        outputMIME.erase(outputMIME.size() - 4, 4);
+        mOutputFormat->setString("mime", outputMIME);
+    }
+
     status_t err = NO_INIT;
     for (size_t ix = 0; ix < matchingCodecs.size(); ++ix) {
         mEncoder = MediaCodec::CreateByComponentName(
-- 
2.7.4

